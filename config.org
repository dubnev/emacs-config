#+TITLE: Emacs Config
#+AUTHOR: peatsheep
#+OPTIONS: toc:nil num:nil

* Required external dependencies

For this configuration to work correctly, the following dependencies must be installed on your system.

- =ripgrep= for fast searching.
- =graphviz= for =org-roam= graph.
- =JetBrains Mono font=.

* SSL config

Allows for pulling from =https= package archives.

#+begin_src emacs-lisp
  (setq tls-checktrust t)
  (setq gnutls-verify-error t)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* Add package repositories

#+begin_src emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+end_src

* Garbage collection tuning

Thanks to [[https://github.com/abrochard/emacs-config/blob/master/configuration.org#garbage-collection-tuning][abrochard config]].

#+begin_src emacs-lisp
  ;; When idle for 30sec run the GC no matter what.
  (defvar k-gc-timer
    (run-with-idle-timer 30 t (garbage-collect)))

  ;; Set garbage collection threshold to 1GB.
  (setq gc-cons-threshold #x40000000)

  ;; Set garbage collection to 20% of heap
  (setq gc-cons-percentage 0.2)
#+end_src

* Automatic package installation via =use-package=

** Install =use-package= and dependencies

[[https://github.com/jwiegley/use-package][use-package]] is a macro that simplifies the syntax for installing and configuring packages.

[[https://github.com/myrjola/diminish.el][diminish]] hides minor-modes from the modeline. =use-package= has support for invoking =diminish= via the =:diminish= keyword.

#+begin_src emacs-lisp
  (mapc
   (lambda (package)
     (unless (package-installed-p package)
       (progn
         (package-refresh-contents)
         (package-install package))))
   '(use-package diminish))
#+end_src

** Trigger =use-package=

=use-package-always-ensure= set to =t= is equivalent to all =use-package= declaractions having the =:ensure= keyword set to =t=.
=:ensure= causes packages to be installed automatically if not already present on system.

#+begin_src emacs-lisp
  (require 'use-package)
  (require 'diminish)

  (setq use-package-always-ensure t)
#+end_src

* Install =better-defaults=

[[https://git.sr.ht/~technomancy/better-defaults][better-defaults]] provides a set of packages and configuration updates to add "better" defaults.
I've used this package for a bit and have grown accustomed to most of these defaults.

The main things I notably get from this are:
- Disable toolbar, menu bar and scroll bar
- =uniquify= library enabled and configured to add directory names to files if the names are not unique (default behavior is to append =<n>= to the end of file names)
- =show-paren-mode= enabled by default
- More extensive =apropros= searches
- =indent-tabs=mode= defaults to nil - spaces instead of tabs

Will maybe pull out these specific changes into dedicated config to avoid risk a new version of =better-defaults= changing some behavior I'm used to, but it should be fine.

#+begin_src emacs-lisp
  (use-package better-defaults)
#+end_src

* UI / UX

** Startup UI / UX behavior

Inhibit startup message and have scratch buffer empty by default.

#+begin_src emacs-lisp
  (setq initial-scratch-message nil)
  (setq inhibit-startup-message t)
#+end_src

** General UI / UX tweaks

Do not make an audible noise when attempting to do something invalid.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

Ask for confirmation before quitting - remove pain of accidental =C-x C-c= fat fingers.

#+begin_src emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Accept =y= and =n= in place of =yes= and =no= respectively.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Auto-indent on =RET= in addition to usual =C-j=.

#+begin_src emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+end_src

** Theme

[[https://draculatheme.com/emacs][dracula]] is a stylish and spooky dark theme.

#+begin_src emacs-lisp
  (use-package dracula-theme
    :config
    (setq dracula-enlarge-headings nil)) ;; Don't change heading/title font sizes

  (load-theme 'dracula t)
#+end_src

** Font

Use the [[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] font if installed on the system.

#+begin_src emacs-lisp
  (if (condition-case nil
          (x-list-fonts "JetBrains Mono")
        (error nil))
      (progn
        (add-to-list 'default-frame-alist '(font . "JetBrains Mono-14"))
        (set-face-attribute 'default nil :font "JetBrains Mono-14")))
#+end_src

#+RESULTS:

** Custom modeline

Very minimal modeline, trim of the original modeline with some custom symbols for style.

#+begin_src emacs-lisp
  (setq-default mode-line-format '(" ùõå"
                                   mode-line-front-space
                                   mode-line-modified
                                   " "
                                   "%[" mode-line-buffer-identification "%]"
                                   "  "
                                   mode-line-modes
                                   mode-line-misc-info
                                   " "
                                   (:propertize " " display ((space :align-to (- right 1))))
                                   mode-line-end-spaces
                                   "‚òâ"
                                   ))
#+end_src

* Configure =helm=

[[https://github.com/emacs-helm/helm][helm]] and similar projects can be hard to describe; =helm= describes itself as an "incremental completion and selection narrowing framework".

In as crude of laymans terms as possible, when you do something that returns many results, =helm= makes it easier to find the result for which you are looking.

** Fuzzy match package dependencies

[[https://github.com/lewang/flx][flx]] provides Sublime style fuzzy text matching.
We can get =helm= support for =flx= via [[https://github.com/PythonNut/helm-flx][helm-flx]].

#+begin_src emacs-lisp
  (use-package flx)
  (use-package helm-flx)
#+end_src

** Install =helm=, rebind common functions, fuzzy match everywhere

#+begin_src emacs-lisp
  ;; (use-package helm
  ;;   :demand ;; Do not defer regardless of circumstances
  ;;   :diminish helm-mode
  ;;   :bind (("M-x" . helm-M-x) ;; Helm interactive function completion
  ;;          ("M-y" . helm-show-kill-ring) ;; Helm kill ring
  ;;          ("C-x b" . helm-mini) ;; Helm buffers list
  ;;          ("C-x C-b" . helm-mini) ;; Almost every time I hit C-x C-b I meant to hit C-x b
  ;;          ("C-x C-f" . helm-find-files)) ;; Helm find files
  ;;   :config
  ;;   (helm-mode 1)
  ;;   (helm-flx-mode 1)
  ;;   (setq helm-mode-fuzzy-match t   ;; Fuzzy match config
  ;;         helm-buffers-fuzzy-matching t
  ;;         helm-lisp-fuzzy-completion t
  ;;         helm-locate-fuzzy-match t
  ;;         helm-M-x-fuzzy-match t
  ;;         helm-recentf-fuzzy-match t)
  ;;   (setq helm-buffer-max-length 48))

  (use-package counsel
    :bind (("C-s" . swiper)
           ("M-x" . counsel-M-x)
           ("M-y" . counsel-yank-pop)
           ("C-x b" . ivy-switch-buffer)
           ("C-x C-b" . ivy-switch-buffer) ;; This key stroke is typically done in error trying to do C-x b
           ("C-x C-f" . counsel-find-file)
           ("C-c C-r" . ivy-resume)))

  (use-package ivy
    :diminish ivy-mode
    :config
    (ivy-mode t)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-height 15)
    (setq ivy-count-format "(%d/%d) "))

  (use-package counsel-projectile
    :diminish counsel-projectile-mode
    :config
    (counsel-projectile-mode t)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

** Configure =ripgrep= via =helm-ag= as search tool

[[https://github.com/emacsorphanage/helm-ag][helm-ag]] allows using [[https://github.com/ggreer/the_silver_searcher][The Silver Searcher]] as your underlying search tool in place of the default (probably =grep=).

However, the project [[https://github.com/BurntSushi/ripgrep][ripgrep]] exisxts, and is currently the fastest search tool available.

There exists a project [[https://github.com/cosmicexplorer/helm-rg][helm-rg]] to provide a =helm= interface for =ripgrep= specifically, but for whatever reason I've run into issues with this.

As a workaround, I use =helm-ag= and configure base command to run the =ripgrep= executable, which has worked perfectly.

#+begin_src emacs-lisp
  ;; (use-package ag)
  ;; (use-package helm-ag
  ;;   :config
  ;;   (setq helm-ag-base-command "rg --no-heading"))
#+end_src

** Install =helm-xref=

[[https://github.com/brotzeit/helm-xref][helm-xref]] provides a =helm= interface for results of the built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html][xref]].

#+begin_src emacs-lisp
  ;; (use-package helm-xref)

#+end_src

* Configure =org-mode=

[[https://orgmode.org/][org-mode]] is a major mode that provides a plain text markup language - that doesn't sound that special in essence, but the ecosystem around org-mode is out of control.

You can manage novel planning, spreadsheets, personal and project TODO management, write research papers...whatever you want basically, and org-mode has a way to make it easier.

The current state of my =org-mode= config is very pared down as I manage all my TODOs in [[https://todoist.com/][Todoist]] and have no plans to migrate off of it anytime soon.

Historically I have managed /_everything_/ in org files, but there were occasional syncing or merge quirks that caused me to lose enough data that I migrated off of it.

This configuration will grow depending on my increased usage of =org-mode=.

** Set environment - important keybindings and =org-indent-mode= hook

#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit t)

  (use-package org
    :bind (("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture))
    :hook (org-mode . org-indent-mode))
#+end_src

** Set org file location

I keep all org files in Dropbox.

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/org")
#+end_src

Likewise, agenda files will live in Dropbox.

#+begin_src emacs-lisp
  (defun willnevillain/set-org-agenda-files ()
    (interactive)
    (setq org-agenda-files (directory-files-recursively org-directory "org$")))

  (willnevillain/set-org-agenda-files)

  (setq org-agenda-custom-commands
        '(("p" tags "PROJECT" nil)
          ("d" "Dashboard" (
                            (agenda ""
                                    ((org-deadline-warning-days 7)))
                            (tags "PROJECT-MAYBE"
                                  ((org-agenda-overriding-header "Active Projects")))))))
#+end_src

** Timed task configuration tweaks

Log completion time of repeated tasks.

#+begin_src emacs-lisp
  (setq org-log-repeat "time")
#+end_src

Hide scheduled items from agenda view if they're already done.

#+begin_src emacs-lisp
  (setq org-agenda-skip-scheduled-if-done t)
#+end_src

Start showing upcoming deadlines in agenda 5 days in advance - default of 14 days is too much for me.

#+begin_src emacs-lisp
  (setq org-deadline-warning-days 5)
#+end_src

** Configure todo keywords

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "|" "DONE(d!)")))
  (setq org-treat-insert-todo-heading-as-state-change t)
#+end_src

** Configure additional export options

*** GitHub Flavored Markdown (gfm)

[[https://github.com/larstvei/ox-gfm][ox-gfm]] adds support for export org files to GitHub Flavored Markdown.

#+begin_src emacs-lisp
  (use-package ox-gfm)
#+end_src

** Configure =org-babel= languages

[[https://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]] allows executing src blocks in org files.

We define the languages that we want =org-babel= to execute.

#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((emacs-lisp . t)))
#+end_src

** Configure =org-mode= utility functions

*** Get absolute path of file in =org-directory=

#+begin_src emacs-lisp
  (defun org-file-path (filename)
      "Return the absolute address of an org file, given its relative name."
      (concat (file-name-as-directory org-directory) filename))
#+end_src

*** Jump to file in =org-directory= w/Ivy

#+begin_src emacs-lisp
  (defun willnevillain/org-find-file ()
      "Leverage Ivy to quickly open any org files."
      (interactive)
      (find-file (org-file-path (ivy-read "Select org file: " (directory-files org-directory nil "\.org$")))))

  (global-set-key (kbd "C-c M-o") 'willnevillain/org-find-file)
#+end_src

** Configure capture templates

#+begin_src emacs-lisp
  (setq org-capture-templates
        `(("i" "Inbox Item" entry (file ,(expand-file-name "inbox.org" org-directory))
           "* %?\nCaptured: %U\n")))
#+end_src

** Configure org-refile

#+begin_src emacs-lisp
  (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

* Configure =org-roam=

#+begin_src emacs-lisp
  (defun willnevillain/create-or-find-org-roam-daily-note ()
      (interactive)
      (if (file-exists-p (concat "~/Dropbox/org/daily/" (shell-command-to-string "echo -n $(date +%Y-%m-%d)") ".org"))
          (org-roam-dailies-find-today)
        (org-roam-dailies-capture-today)))

    (use-package org-roam
      :diminish org-roam-mode
      :config
      (progn
        (setq org-roam-directory org-directory
              org-roam-dailies-directory "daily/"
              org-roam-dailies-capture-templates      `(("d" "default" entry
                                                         #'org-roam-capture--get-point
                                                         ,(concat
                                                           "* Tasks\n"
                                                           "* Work Focuses\n"
                                                           "* Journal\n"
                                                           "** Morning\n"
                                                           "** Evening\n"
                                                           "* Checklists\n"
                                                           "** Morning\n"
                                                           "- [ ] Check notebook, Todoist =Inbox= and inbox.org for incoming items\n"
                                                           "- [ ] Check Todoist =Today= and yesterday's daily note for overflow items\n"
                                                           "- [ ] Ensure Todoist and Emacs task states in sync\n"
                                                           "- [ ] Sort and prioritize new items\n"
                                                           "- [ ] Add personal and work 'must dos' to docket, and work focuses if applicable\n"
                                                           "- [ ] Reflect on 'want to dos' and projects\n"
                                                           "  - [ ] Add achievables to docket\n"
                                                           "  - [ ] Reflect on important daily habits and note when you will do them\n"
                                                           "- [ ] Reflect on what is slated for today. Is this reasonable? Prune as necessary.\n"
                                                           "- [ ] Journal thoughts, ambitions, goals\n"
                                                           "** Evening\n"
                                                           "- [ ] Check Todoist =Inbox= and inbox.org for incoming items\n"
                                                           "- [ ] Reflect on incomplete items. What should be deprioritized, what should be overflowed?\n"
                                                           "- [ ] Ensure Todoist and Emacs task states in sync\n"
                                                           "- [ ] Sort and prioritize new items\n"
                                                           "- [ ] Reflect on 'want to dos' and projects\n"
                                                           "  - [ ] Did achievables get completed / will be completed before bed? Reflect on why.\n"
                                                           "  - [ ] Did you do the important daily habits / will you do them before bed? Reflect on why.\n"
                                                           "- [ ] Journal on how the day went and anything else\n")
                                                         :file-name "daily/%<%Y-%m-%d>"
                                                         :head "#+title: %<%Y-%m-%d>\n\n")))
        (org-roam-mode t))
      :bind (("C-c M-t" . willnevillain/create-or-find-org-roam-daily-note)
             ("C-c M-p" . org-roam-dailies-find-previous-note)))
#+end_src

* Configure =projectile=

[[https://github.com/bbatsov/projectile][projectile]] is a very powerful library for interacting with multiple projects.
It provides features and functions that operate on the project level, such as jumping to a file in a project, jump to file at point in project, search in project, etc.

** Install =projectile= and core configuration

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (projectile-mode)
    (setq projectile-project-search-path '("~/code")) ;; Specify dir(s) to search for projects
    (projectile-discover-projects-in-search-path) ;; Trigger project discovery
    (setq projectile-enable-caching t) ;; Cache search results
    (add-to-list 'projectile-globally-ignored-directories "node_modules")) ;; Never search in
#+end_src

** Integrate with =helm=

[[https://github.com/bbatsov/helm-projectile][helm-projectile]] provides =helm= integration for =projectile= - it's written by the same author as =projectile=, the prolific [[https://github.com/bbatsov][Bozhidar Batsov]].

#+begin_src emacs-lisp
  ;; (use-package helm-projectile
  ;;   :bind (("C-c v" . helm-projectile)
  ;;          ("C-c f" . helm-projectile-find-file)
  ;;          ("C-c b" . helm-projectile-switch-to-buffer)
  ;;          ("C-c s" . helm-do-ag-project-root)
  ;;          ("C-c w" . helm-projectile-switch-project)))
#+end_src

* Cofigure =magit=

[[https://github.com/magit/magit][magit]] is a Git porcelain for Emacs, and honestly one of the killer apps of Emacs.

#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src

[[https://github.com/alphapapa/magit-todos][magit-todos]] for visualizing =TODO= items marked across the source.

#+begin_src emacs-lisp
  (use-package magit-todos)
#+end_src

* Programming environment

Anything related to a specific programming language, or programming major mode adjacent, lives here.

** Configure =flycheck=

[[https://github.com/flycheck/flycheck][flycheck]] provides on the fly syntax checking; it supports [[https://www.flycheck.org/en/latest/languages.html][many languages and checkers]].

#+begin_src emacs-lisp
  (use-package flycheck
    :config
    (global-flycheck-mode))
#+end_src

** Configure =company=

[[https://company-mode.github.io/][company]] is an in-buffer text completion framework; put more simply, when you're typing something, company will create a dropdown of possible options for what you're typing.

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :config
    (global-company-mode)
    (setq company-idle-delay 0.2 ;; show candidates 0.3 sec after idle from typing
          company-minimum-prefix-length 1 ;; show candidates as early as 1 character
          company-selection-wrap-around t ;; if you scroll past last/first candidate, wrap around
          global-company-modes '(not org-mode))) ;; disable company for modes
#+end_src

[[https://github.com/company-mode/company-quickhelp][company-quickhelp]] displays a pop-up when idling on a company candidate with documentation on the candidate.

#+begin_src emacs-lisp
  (use-package company-quickhelp
    :config
    (setq company-quickhelp-delay 0.5)
    (company-quickhelp-mode))
#+end_src

** Configure support for TypeScript + ecosystem

Currently I only do Backend Node.js TypeScript programming - as a result there is slim support for anything pertaining to the web or vanilla JS at this time.

*** Install and configure =tide=

[[https://github.com/ananthakumaran/tide][tide]] is an IDE for TypeScript for Emacs.

#+begin_src emacs-lisp
  (use-package typescript-mode)

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l")

    :hook
    (typescript-mode . lsp)
    (javascript-mode . lsp)
    (lsp-mode . lsp-enable-which-key-integration)

    :config
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-eslint-validate [javascript typescript])
    (setq lsp-eslint-package-manager "yarn")
    (setq lsp-eslint-format nil)
    (setq lsp-eslint-trace-server t)
    (setq lsp-log-io t)

    :commands lsp)

  (use-package lsp-ui
    :config (setq lsp-ui-sideline-show-code-actions nil)
    :commands lsp-ui-mode)

  ;; (use-package helm-lsp :commands helm-lsp-workspace-symbol)
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
  (use-package which-key :diminish which-key-mode :config (which-key-mode))
#+end_src

*** Node version management with =nvm=

#+begin_src emacs-lisp
  (use-package nvm
    :hook (typescript-mode . nvm-use-for))
#+end_src

*** Add node_modules =.bin= folder to =exec-path=

[[https://github.com/codesuki/add-node-modules-path][add-node-modules-path]] provides a function that searches current file parent directories for a =node_modules/.bin/= folder.

This allows using project based installations of tools like =eslint= and =prettier=, which is my preference for controlling versions.

#+begin_src emacs-lisp
  (use-package add-node-modules-path
    :hook (typescript-mode . add-node-modules-path)
    :hook (json-mode . add-node-modules-path)
    :hook (yaml-mode . add-node-modules-path))
#+end_src

*** Install and configure =prettier-js=

[[https://github.com/prettier/prettier-emacs][prettier-js]] provides formatting support via the [[https://prettier.io/][prettier]] code formatter.

=tide= offers formatting support that aligns with TypeScript standards, but I work with a few codebases that prefer local =prettier= configs.

#+begin_src emacs-lisp
  (use-package prettier-js
    :hook (typescript-mode . prettier-js-mode)
    :hook (json-mode . prettier-js-mode)
    :hook (yaml-mode . prettier-js-mode))
#+end_src

*** Indium

#+begin_src emacs-lisp
  (use-package indium)
#+end_src


** Configure development adjacent major modes

*** Install =yaml-mode=

[[https://github.com/yoshiki/yaml-mode][yaml-mode]] provides YAML file editing support.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

*** Install =markdown-mode=

[[https://github.com/jrblevin/markdown-mode][markdown-mode]] provides Markdown editing support.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)))
#+end_src

*** Install =json-mode=

[[https://github.com/joshwnj/json-mode][json-mode]] provides JSON file editing support.

#+begin_src emacs-lisp
  (use-package json-mode
    :hook (json-mode . (lambda ()
              (make-local-variable 'js-indent-level)
              (setq js-indent-level 2))))
#+end_src

*** Install =dockerfile-mode=

[[https://github.com/spotify/dockerfile-mode][dockerfile-mode]] provides Dockerfile editing support (and image building as well).
Somewhat of a surprise to me, this is maintained by Spotify.

#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src

** Configure programming related UI packages

*** Install =git-gutter=

[[https://github.com/emacsorphanage/git-gutter][git-gutter]] provides visual indicators in the left gutter of a buffer of git changes.

#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :config (global-git-gutter-mode 1))
#+end_src

* Infrastructure and application management

Anything related to connecting to, declaring configuration for or otherwise managing live infrastructure or applications.

** Configure =kubel=

[[https://github.com/abrochard/kubel][kubel]] allows controlling Kubernetes with limited permissions through Emacs.

The [[https://github.com/abrochard][author]] gave an interesting talk about how the extension was born and built, which I encourage you to watch [[https://www.youtube.com/watch?v=w3krYEeqnyk][here]].

#+begin_src emacs-lisp
  (use-package kubel)
#+end_src

* Configure =ejc-sql=

[[https://github.com/kostafey/ejc-sql][ejc-sql]] is an Emacs SQL client

First, install =auto-complete= for autocompletion.

#+begin_src emacs-lisp
  (use-package auto-complete)
#+end_src

#+begin_src emacs-lisp
  (use-package ejc-sql
    :bind (("C-c e b" . ejc-get-temp-editor-buffer))
    :config
    (setq clomacs-httpd-default-port 8090)
    (setq ejc-completion-system 'standard)
    (add-hook 'ejc-sql-minor-mode-hook (lambda ()
                                         ;; eldoc
                                         (ejc-eldoc-setup)

                                         ;; autocompletion
                                         (auto-complete-mode t)
                                         (ejc-ac-setup)

                                         ;; company-mode support (global-company enabled)
                                         (push 'ejc-company-backend company-backends))))
#+end_src

* Configure =restclient-mode=

#+begin_src emacs-lisp :output silent
  (use-package restclient
    :mode (("\\.http\\'" . restclient-mode)))
#+end_src

* Configure =eshell=

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][eshell]] is a shell-like command interpreter implemented entirely in Emacs Lisp.

=eshell= is an interesting beast that I won't say I've come close to taming.

Recommended reading / viewing to demystify =eshell=:
- [[https://masteringemacs.org/article/complete-guide-mastering-eshell][Mastering Emacs article "Mastering Eshell"]]
- [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrams London Emacs Meetup talk "Introduction to EShell"]]

** Package configuration

#+begin_src emacs-lisp
  (use-package eshell
    :config
    (setq eshell-scroll-to-bottom-on-input 'all ;; Scroll to bottom of buffer when entering input
          eshell-error-if-no-glob t ;; Error if glob pattern does not match
          eshell-hist-ignoredups t ;; ???, but a lot of people have it
          eshell-save-history-on-exit t ;; Save history of eshell process on exist
          eshell-prefer-lisp-functions nil ;; Prefer external commands to Lisp functions
          eshell-destroy-buffer-when-process-dies t)) ;; When eshell process exists, destroy buffer
#+end_src

** Utility functions

Defined functions prefaced with =eshell/= should be invokable using everything after the =/= in eshell. 

#+begin_src emacs-lisp
  (defun eshell/clear ()
    "Clear eshell buffer."
    (let ((inhibit-read-only t))
      (erase-buffer)))

  (defun eshell/close ()
    "Close eshell window."
    (delete-window))
#+end_src

=eshell= related interactive functions defined here.

#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
      current buffer's file. The eshell is renamed to match that
      directory to make multiple eshell windows easier."
    (interactive)
    (let* ((height (/ (window-total-height) 4)))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")))

  (bind-key "C-!" 'eshell-here)
#+end_src

Miscellaneous non-interactive and non-=eshell/= utility functions defined below.

#+begin_src emacs-lisp
  ;; (add-hook 'eshell-mode-hook ;; Bind key to view preconfigured Helm view of eshell history
  ;;           (lambda ()
  ;;             (define-key eshell-mode-map (kbd "M-r") 'helm-eshell-history)))

  (defun eshell-pop--kill-and-delete-window ()
    "Used on eshell exit hook, will delete the window if not the only one in the frame"
    (unless (one-window-p)
      (delete-window)))

  (add-hook 'eshell-exit-hook 'eshell-pop--kill-and-delete-window)
#+end_src

** Visual command and subcommand definitions

=eshell= is not a fully functioning terminal, and cannot handle certain visual commands.

#+begin_src emacs-lisp
  (setq eshell-visual-command '("htop" "top" "less" "more" "screen" "node"))
  (setq eshell-visual-subcommands '("git" "log" "diff" "show" "ssh" "yarn" "npm" "docker" "docker-compose"))
#+end_src

Related: set Unix Pager to be the =cat= command.

#+begin_src emacs-lisp
  (setenv "PAGER" "cat")
#+end_src

* Configure =yasnippet=

[[https://github.com/joaotavora/yasnippet][yasnippet]] is a template and expansion system for Emacs.

Snippets from the [[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets community library]] are loaded alongside my own defined snippets.

My snippets are located at =~/.emacs.d/snippets=, community library at =~/.emacs.d/yasnippet-snippets=.

#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/yasnippet-snippets")
    (yas-global-mode)
    (global-set-key (kbd "M-/") 'company-yasnippet))
#+end_src

* Configure blogging tool(s)

[[https://github.com/masasam/emacs-easy-hugo][easy-hugo]] is a package that makes it easier to work with the [[https://gohugo.io/][hugo]] static site generator.

#+begin_src emacs-lisp
  (use-package easy-hugo
    :init
    (setq easy-hugo-basedir "~/code/blog/")
    (setq easy-hugo-url "https://willnevillain.github.io")
    (setq easy-hugo-postdir "content/blog")
    (setq easy-hugo-default-ext ".org"))
#+end_src

* Global utility functions

Any utility functions that are used at a global level go here.

** Jump to this configuration file

#+begin_src emacs-lisp
  (defun willnevillain/goto-configuration ()
    "Go to org configuration file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (global-set-key (kbd "C-c M-c") 'willnevillain/goto-configuration)
#+end_src

** Toggle font size for streaming mode
#+begin_src emacs-lisp
  (defun willnevillain/toggle-stream-fontsize ()
    "Toggle the font size between default and large for streaming"
    (interactive)
     (if (string= (cdar default-frame-alist) "JetBrains Mono-24")
         (progn
           (setcar default-frame-alist '(font . "JetBrains Mono-14"))
           (set-face-attribute 'default nil :font "JetBrains Mono-14"))
       (progn
         (setcar default-frame-alist '(font . "JetBrains Mono-24"))
         (set-face-attribute 'default nil :font "JetBrains Mono-24"))))
#+end_src

* Miscellaney

Configuration that doesn't really fit elsewhere or deserve a top level heading go here.

** Configure =helpful= for better Emacs docs

[[https://github.com/Wilfred/helpful][helpful]] provides much more context and detail in the help buffer.

We rebind all the command help keybinds to their =helpful= equivalent.

#+begin_src emacs-lisp
  (use-package helpful
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           ("C-h F" . helpful-function)
           ("C-h C" . helpful-command)))
#+end_src

** Configure =exec-path-from-shell= (OS X)

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] copies specified environment variables from your shell to Emacs.

On OS X in particular, Emacs launched as a GUI does not inherit all the shell env vars.

#+begin_src emacs-lisp
  (setq exec-path-from-shell-arguments nil) ;; Suppress default arg to open interactive shell

  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src 

** Configure backups to go into one folder

I dislike polluting the file tree with Emacs backups - I put them all in =~/.emacs.d/backups=.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

** Configure =flyspell= spell checking

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][flyspell]] (built in) will highlight misspelled words by way of an underlying spell checking program (on OS X it is probably =ispell=).

I only want global spell checking in =org-mode= buffers, and for programming mode buffers enable =flyspell-prog-mode= which only spell checks comments and strings.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+end_src

** Configure diminished minor modes

There are a few minor modes not specifically configured in this file that I like to diminish.

#+begin_src emacs-lisp
  (diminish 'abbrev-mode)
  (diminish 'auto-revert-mode)
  (diminish 'eldoc-mode)
  (diminish 'flyspell-mode)
#+end_src

* Configure and load custom file

By default, Emacs places anything customized via =customize= at the bottom of =init.el=.

Prefer to place all this cruft in a specific file.

#+begin_src emacs-lisp
  (setq custom-file
        (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src

