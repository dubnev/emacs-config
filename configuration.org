#+TITLE: Emacs Configuration
#+AUTHOR: William Neville
#+EMAIL: william@neville.com
#+OPTIONS: toc:nil num:nil

* Introduction

Almost all of this lifted from other, more sophisticated Emacs users. Those of 
note linked below:
[[https://github.com/abrochard/emacs-config][abrochard]]
[[https://github.com/hrs/dotfiles/tree/master/emacs/.emacs.d][hrs]]

* Configure =use-package=

Package installation and configuration done via =use-package=. See =init.el= for
baseline configuration. 

Ensure that =use-package= installs package if not already installed.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC

* UI/UX
I only use GUI emacs - these are baseline modifications.
** Windows, Frames and Buffers
*** Disable noisy emacs GUI elements
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(tool-bar-mode -1)
#+END_SRC
*** If OS X "bonks" at me one more time
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
*** Start in full screen by default
#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC
*** Scratch buffer empty, please.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil)
#+END_SRC
*** Inhibit startup message.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Global line numbers
#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC
*** 
** UI
*** Theme
Trying out tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :defer t
  :config
  (color-theme-sanityinc-tomorrow-eighties))
#+END_SRC

Some customize changes for tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(org-block ((t (:inherit shadow :background "gray20")))))
#+END_SRC

But keep gruvbox around in case I grow weary of tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :defer t)
  ;; :config (load-theme 'gruvbox-dark-medium t)
#+END_SRC
*** Nyan-mode
What would I even be doing with my life without this.
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :config (nyan-mode))
#+END_SRC
*** All the icons!
all-the-icons makes neotree look cooler. Workaround to install fonts if not already installed.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :config (lambda ()  ;; workaround to only install fonts if not already installed
            (unless (member "all-the-icons" (font-family-list))
              (all-the-icons-install-fonts t))))
#+END_SRC
** UX
*** Ask for confirmation before quitting
The number of times I've fat fingered C-x C-c...
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC
*** Accept "y" and "n" in place of "yes" and "no"
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Auto-indent on RET rather than just C-j
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC
* Personal Information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "William Neville"
        user-mail-address "william@neville.com"
        calendar-latitude 40.72
        calendar-longitude -73.99
        calendar-location-name "New York, NY")
#+END_SRC

* Version Control
** Magit

You can basically do everything from magit-status.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-x g" . magit-status))
#+END_SRC

** Forge
Interactions with GitHub
#+BEGIN_SRC emacs-lisp
(use-package forge)
#+END_SRC
** Utility Functions
*** Git blame
#+BEGIN_SRC emacs-lisp
(defun git-blame-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil 
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil 
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s" line-number (buffer-string)))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))
#+END_SRC

* Org Mode
** Set environment

Base configuration.

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda))
         ("C-c c" . org-capture))
#+END_SRC

I like to log when tasks were completed.

#+BEGIN_SRC emacs-lisp
(setq org-log-done t)
#+END_SRC

I keep all my org stuff in Dropbox. Experimenting with =beorg= on iOS,
so this behooves me.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Dropbox/org"))
#+END_SRC

** Org-babel
Load up the languages we want org-babel to be able to execute.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (python . t)
         (shell . t)
         (org . t))))
#+END_SRC

** Org-bullets
More readable.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** Org-download
I like to include images in my org files - this allows drag-n-drop as well as do screenshots. Be wary that images tend to be...large.
#+BEGIN_SRC emacs-lisp
(use-package org-download)
#+END_SRC
** Epresent
Presentation mode for org-mode
#+BEGIN_SRC emacs-lisp
(use-package epresent)
#+END_SRC
** Capture Templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry
           (file+headline "~/Dropbox/org/gtd.org" "Tasks")
           "* TODO %?\n %i\n %a")
           ("e" "Emacs idea/project" entry
           (file+headline "~/Dropbox/org/emacs-ideas.org" "Ideas")
           "* %?\n")))
#+END_SRC

* Helm
#+BEGIN_SRC emacs-lisp
(use-package flx)
(use-package helm-flx)
(use-package helm
  :demand
  :diminish helm-mode
  :bind (("M-x" . helm-M-x)
         ("M-y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files))
  :config
  (helm-mode 1)
  (helm-flx-mode +1)
  (setq helm-M-x-fuzzy-match t)
  (setq helm-locate-fuzzy-match t)
  (setq helm-lisp-fuzzy-completion t)
  (setq helm-buffer-max-length 30))
#+END_SRC
* Development
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile)
#+END_SRC
** Python
Using elpy currently - would like to move to using MS Python LSP, but it's not mature enough yet.
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt")
  (elpy-enable))
#+END_SRC
Treat things in snake_case as one word, only in Python mode
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'superword-mode)
#+END_SRC
*** Python utility functions

These are idiomatic to my current work codebase,
and invoke fabric commands to set environment correctly,
but feel free to harvest any useful bits.

Search and run all tests for function name under point (by naming convention).
This needs some cleaning up, esp as we pollute the default-directory, but it works for now.
#+BEGIN_SRC emacs-lisp
(defun run-pytest-for-word-at-point ()
  (interactive)  ;; TODO add a test for if (thing-at-point 'word) is nil - run all tests in file
  (run-pytest-for-word (thing-at-point 'word)))

(defun run-pytest-for-word (word)
  (setq default-directory  ;; need to search for tests from top-level dir of project
        (shell-command-to-string "echo -n (git rev-parse --show-toplevel)"))
  (let ((process
         (start-process-shell-command "*pytest*" "*pytest*"
                                      (concat  ;; trim any leading "_"s
                                       (if (string-equal (substring word 0 1) "_")
                                           "ftf test"
                                         "ftf test_")
                                       word))))
    (with-current-buffer (process-buffer process)
      (display-buffer (current-buffer))
      (require 'shell)
      (shell-mode)
      (set-process-filter process 'comint-output-filter))))  ;; for handling ansi-colors

(add-hook 'python-mode-hook
          (lambda () (local-set-key (kbd "C-c t") 'run-pytest-for-word-at-point)))
#+END_SRC
** Development adjacent
*** Restclient
This is a pretty cool package that I haven't dived into enough.
#+BEGIN_SRC emacs-lisp
(use-package restclient)
#+END_SRC
*** Fish Shell
#+BEGIN_SRC emacs-lisp
(use-package fish-mode)
#+END_SRC
*** Yaml Mode
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC
*** JSON Mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode)
#+END_SRC
*** Dockerfile Mode
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode)
#+END_SRC
* Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))
#+END_SRC
* Elfeed
RSS feeds - should move the feed definitions to another file.
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :bind ("C-x w" . elfeed)
  :config
  (setq elfeed-feeds
      '(("http://xkcd.com/rss.xml" comic)
	("https://www.smbc-comics.com/rss.php" comic)
	("http://reddit.com/r/emacs/.rss" emacs)
	("http://planet.emacsen.org/atom.xml" emacs)
	("http://pragmaticemacs.com/feed/" emacs)
        ("https://blog.jessfraz.com/index.xml" tech)))
  (setq-default elfeed-search-filter "@1-week-ago +unread"))
#+END_SRC
* Neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :config
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
#+END_SRC
* Misc Configuration
** Better defaults
#+BEGIN_SRC emacs-lisp
(use-package better-defaults)
#+END_SRC
** exec-path-from-shell (OSX specific)
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs
   '("PATH"))))
#+END_SRC
** Backups in one folder
Don't like to pollute the file tree with backups if I don't have to.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
** Eshell here
Thanks to [[https://github.com/abrochard/emacs-config/blob/master/configuration.org#eshell-here][Adrien]] for this one.
 #+BEGIN_SRC emacs-lisp
 (defun eshell-here ()
  "Opens up a new shell in the directory associated with the
    current buffer's file. The eshell is renamed to match that
    directory to make multiple eshell windows easier."
  (interactive)
  (let* ((height (/ (window-total-height) 3)))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (insert (concat "ls"))
    (eshell-send-input)))

(bind-key "C-!" 'eshell-here)
 #+END_SRC
* Unsorted
Empty!...for now.

