#+TITLE: Emacs Configuration
#+AUTHOR: William Neville
#+EMAIL: william@neville.com
#+OPTIONS: toc:nil num:nil

* Introduction

Almost all of this lifted from other, more sophisticated Emacs users. Those of 
note linked below:
[[https://github.com/abrochard/emacs-config][abrochard]]
[[https://github.com/hrs/dotfiles/tree/master/emacs/.emacs.d][hrs]]
[[https://jamiecollinson.com/blog/my-emacs-config/][jamie collinson]]

* Configure =use-package=

Package installation and configuration done via =use-package=. See =init.el= for
baseline configuration. 

Ensure that =use-package= installs package if not already installed.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC

* Benchmarking

Benchmarking Emacs startup. We want to include this as early as possible in this config.

#+BEGIN_SRC emacs-lisp
  (use-package benchmark-init
    :ensure t
    :config
    (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+END_SRC

Can get results on startup with =benchmark-init/show-durations-tabulated=

* Better Defaults

Main things I desire that we get with =better-defaults= are as follows:
- Disable toolbar, menu bar, scroll bar
- =uniquify= library to append directory names in buffer if file name not unique
- =C-x C-b= uses ibuffer
- =show-paren-mode= enabled
- More extensive apropos search
- =indent-tabs-mode= defaulting to nil - spaces instead of tabs

#+BEGIN_SRC emacs-lisp
(use-package better-defaults)
#+END_SRC

* UI/UX
I only use GUI emacs - these are baseline modifications.
** Windows, Frames and Buffers
*** If OS X "bonks" at me one more time
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
*** Start in full screen by default
#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC
*** Scratch buffer empty, please.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil)
#+END_SRC
*** Inhibit startup message.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Column number mode
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC
** UI
*** Theme
Trying out tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :defer t
  :config
  (color-theme-sanityinc-tomorrow-eighties))
#+END_SRC

Some customize changes for tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(org-block ((t (:inherit shadow :background "gray20")))))
#+END_SRC

But keep gruvbox around in case I grow weary of tomorrow-eighties
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :defer t)
  ;; :config (load-theme 'gruvbox-dark-medium t)
#+END_SRC
*** Font

Use Hack font if installed.

#+BEGIN_SRC emacs-lisp
(if (condition-case nil
        (x-list-fonts "Hack")
      (error nil))
    (progn
      (add-to-list 'default-frame-alist '(font . "Hack-12"))
      (set-face-attribute 'default nil :font "Hack-12")))
#+END_SRC

*** All the icons!
all-the-icons makes neotree look cooler. Workaround to install fonts if not already installed.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :config (lambda ()  ;; workaround to only install fonts if not already installed
            (unless (member "all-the-icons" (font-family-list))
              (all-the-icons-install-fonts t))))
#+END_SRC
** UX
*** Ask for confirmation before quitting
The number of times I've fat fingered C-x C-c...
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC
*** Accept "y" and "n" in place of "yes" and "no"
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Auto-indent on RET rather than just C-j
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC
* Personal Information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "William Neville"
        user-mail-address "william@neville.com"
        calendar-latitude 40.72
        calendar-longitude -73.99
        calendar-location-name "New York, NY")
#+END_SRC

* Version Control
** Magit

You can basically do everything from magit-status.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-x g" . magit-status))
#+END_SRC

** Utility Functions
*** Git blame
#+BEGIN_SRC emacs-lisp
(defun git-blame-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil 
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil 
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s" line-number (buffer-string)))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))
#+END_SRC

* Org Mode
** Set environment

Base configuration.

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda))
         ("C-c c" . org-capture))
#+END_SRC

I like to log when tasks were completed, and log completion time of repeated tasks.

#+BEGIN_SRC emacs-lisp
(setq org-log-done t)
(setq org-log-repeat "time")
#+END_SRC

I keep all my org stuff in Dropbox. Experimenting with =beorg= on iOS,
so this behooves me.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Dropbox/org"))
#+END_SRC

Add some more states for todos.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAIT(w@/!)""DONE(d!)")))
(setq org-todo-keyword-faces
           '(("WAIT" . "yellow")))
#+END_SRC

** Exporting

Export to github flavored markdown
#+BEGIN_SRC emacs-lisp
  (use-package ox-gfm)
#+END_SRC

** Org-babel
Load up the languages we want org-babel to be able to execute.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (python . t)
         (shell . t)
         (org . t))))
#+END_SRC

** Org-bullets
More readable.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** Capture Templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry
           (file+headline "~/Dropbox/org/gtd.org" "Tasks")
           "* TODO %?\n %i\n %a")
           ("e" "Emacs idea/project" entry
           (file+headline "~/Dropbox/org/emacs-ideas.org" "Ideas")
           "* %?\n")))
#+END_SRC

** org-projectile
#+BEGIN_SRC emacs-lisp
  (use-package org-projectile
    :bind ("C-c n p" . org-projectile-project-todo-completing-read)
    :config
    (progn
      (setq org-projectile-projects-file
            "~/Dropbox/org/projects.org")
      (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
      (push (org-projectile-project-todo-entry) org-capture-templates)))
#+END_SRC
* Helm

Helm for our completion engine - I like both Helm and Ivy, but prefer Helm a little more.

First installing related fuzzy match packages so we can configure them alongside the main Helm package.

#+BEGIN_SRC emacs-lisp
  (use-package flx)
  (use-package helm-flx)
#+END_SRC

Now the juice, don yer hats.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand
    :diminish helm-mode
    :bind (("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-mini)
           ("C-x C-f" . helm-find-files))
    :config
    (helm-mode 1)
    (helm-flx-mode +1)
    (setq helm-M-x-fuzzy-match t)
    (setq helm-locate-fuzzy-match t)
    (setq helm-lisp-fuzzy-completion t)
    (setq helm-buffer-max-length 48))
#+END_SRC

Sort of related, let's use =ripgrep= for our searching, and bring in =helm-rg= as well.
EDIT: there's some bug I'm encountering trying to use =helm-rg=, going to default back to =helm-ag= for the moment.

#+BEGIN_SRC emacs-lisp
  ;;(use-package rg)
  ;;(use-package helm-rg
  ;;  :config (setq helm-rg-default-directory 'git-root))
  (use-package ag)
  (use-package helm-ag)
#+END_SRC

* Development
** Projectile

Love me some projectile.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (setq projectile-project-search-path '("~/.emacs.d/"))
    (if (file-directory-p "~/code/")
        (add-to-list 'projectile-project-search-path "~/code/"))
    (if (file-directory-p "~/dev/")
        (add-to-list 'projectile-project-search-path "~/dev/"))
    (projectile-discover-projects-in-search-path)
    (setq-default projectile-mode-line
     '(:eval
       (if (file-remote-p default-directory)
           " Proj"
         (format " Proj[%s]" (projectile-project-name)))))
    (add-to-list 'projectile-globally-ignored-directories "node_modules")
    (add-to-list 'projectile-globally-ignored-directories "env")
    (add-to-list 'projectile-globally-ignored-directories ".venv"))
#+END_SRC

Let's add some Helm to that.

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :bind (("C-c v" . helm-projectile)
           ("C-c f" . helm-projectile-find-file)
           ("C-c b" . helm-projectile-switch-to-buffer)
  ;;         ("C-c s" . helm-projectile-rg)
           ("C-c s" . helm-projectile-ag)
           ("C-c w" . helm-projectile-switch-project)))
#+END_SRC

** LSP

Configure LSP - I only use it for Python, currently.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :config
    (require 'lsp-clients)

    (use-package lsp-ui
      :config
      (setq lsp-ui-sideline-ignore-duplicate t)
      (add-hook 'lsp-mode-hook 'lsp-ui-mode))

    (use-package company-lsp
      :config
      (push 'company-lsp company-backends))

    (use-package helm-lsp
      :commands (helm-lsp-workspace-symbol helm-lsp-global-workspace-symbol))

    (add-hook 'python-mode-hook 'lsp)

    (setq lsp-language-id-configuration 
     '((python-mode . "python")))

    ;; NB: only required if you prefer flake8 instead of the default
    ;; send pyls config via lsp-after-initialize-hook -- harmless for
    ;; other servers due to pyls key, but would prefer only sending this
    ;; when pyls gets initialised (:initialize function in
    ;; lsp-define-stdio-client is invoked too early (before server
    ;; start)) -- cpbotha
    (defun lsp-set-cfg ()
      (let ((lsp-cfg `(:pyls (:configurationSources ("flake8")))))
        (lsp--set-configuration lsp-cfg)))

    (add-hook 'lsp-after-initialize-hook 'lsp-set-cfg)

    ;; LSP debugging
    ;;(setq lsp-print-io t)
    ;;(setq lsp-trace t)
    ;;(setq lsp-print-performance t)
    )
#+END_SRC

** Python
Trying out lsp, but keeping elpy config around just in case
#+BEGIN_SRC emacs-lisp
  ;;(use-package elpy
  ;;  :config
  ;;  (setq python-shell-interpreter "ipython"
  ;;        python-shell-interpreter-args "-i --simple-prompt")
  ;;  (elpy-enable))
#+END_SRC

Need to use =pyvenv= to activate the relevant virtualenv for your project.
#+BEGIN_SRC emacs-lisp
(use-package pyvenv)
#+END_SRC

*** Python utility functions

These are idiomatic to my current work codebase,
and invoke fabric commands to set environment correctly,
but feel free to harvest any useful bits.

THE MOST IMPORTANT ONE: for some reason, even after activating a virtualenv with =pyvenv-activate=, each time I visit a new Python file in the project, a new LSP process will spawn.
This leaves me with something on the order of 40-50 processes before it eventually stops working, raising a generic "Too many open files" LSP OSError.
I start off my work flow by calling the below function to set my virtualenv and the VIRTUALENV environment variable for the relevant work project.
#+BEGIN_SRC emacs-lisp
  (defvar olympus-env-dir "/Users/will/code/olympus/env")

  (defun olympus-activate ()
    (interactive)
    (pyvenv-activate olympus-env-dir)
    (setenv "VIRTUALENV" olympus-env-dir))
#+END_SRC

Search and run all tests for function name under point (by naming convention).
This needs some cleaning up, esp as we pollute the default-directory, but it works for now.
#+BEGIN_SRC emacs-lisp
  (defun run-pytest-for-word-at-point ()
    (interactive)  ;; TODO add a test for if (thing-at-point 'word) is nil - run all tests in file
    (run-pytest-for-word (thing-at-point 'word)))

  (defun run-pytest-for-word (word)
    (setq default-directory  ;; need to search for tests from top-level dir of project
          (shell-command-to-string "echo -n (git rev-parse --show-toplevel)"))
    (let ((process
           (start-process-shell-command "*pytest*" "*pytest*"
                                        (concat  ;; trim any leading "_"s
                                         (if (string-equal (substring word 0 1) "_")
                                             "ftf test"
                                           "ftf test_")
                                         word))))
      (with-current-buffer (process-buffer process)
        (display-buffer (current-buffer))
        (require 'shell)
        (shell-mode)
        (set-process-filter process 'comint-output-filter))))  ;; for handling ansi-colors

  (add-hook 'python-mode-hook
            (lambda () (local-set-key (kbd "C-c t") 'run-pytest-for-word-at-point)))
#+END_SRC
** JavaScript / Web

=js2-mode= is 1 better than build in JS Mode.
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :defer t
    :mode "\\.js\\'"
    :config
    (setq-default js-indent-level 2)
    (setq-default js2-ignored-warnings '("msg.extra.trailing.comma")))
#+END_SRC

=js2-refactor= for some additional refactoring options on top of =js2-mode=.
#+BEGIN_SRC emacs-lisp
  (use-package js2-refactor
    :defer t
    :config
    (js2r-add-keybindings-with-prefix "C-c C-r")
    :hook
    (js2-mode . js2-refactor-mode))
#+END_SRC

=rjsx-mode= for working with JSX.
#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :defer t)
#+END_SRC

=web-mode= for html/css.
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.html\\'"
    :config
    (setq web-mode-enable-auto-pairing t)
    (setq web-mode-enable-css-colorization t)
    (setq web-mode-markup-indent-offset 2))
#+END_SRC

=web-beautify= for prettifying html/css by leveraging =js-beautify= - install this with =npm install -g js-beautify=.
#+BEGIN_SRC emacs-lisp
  (use-package web-beautify
    :bind (:map web-mode-map
                ("C-c b" . web-beautify-html)
                :map js2-mode-map
                ("C-c b" . web-beautify-js)))
#+END_SRC

=prettier-js= for autoformatting of JS. Need to have =prettier= installed on host via your package manager.
#+BEGIN_SRC emacs-lisp
  (use-package prettier-js
    :defer t
    :config
    (setq prettier-js-args '(
                             "--trailing-comma" "es5"
                             "--single-quote" "true"
                             "--print-width" "100"
                             ))
    :hook
    (js2-mode. prettier-js-mode)
    (rjsx-mode . prettier-js-mode))
#+END_SRC

=npm-mode= is a really nifty little package. Command map [[https://github.com/mojochao/npm-mode#command-keymap][here]].
#+BEGIN_SRC emacs-lisp
  (use-package npm-mode
    :defer t
    :hook
    (js2-mode . npm-mode)
    (rjsx-mode . npm-mode))
#+END_SRC

Utility function (hooked into flycheck) to use local eslint when present.
#+BEGIN_SRC emacs-lisp
  (defun dub/use-eslint-from-node-modules ()
      "Set local eslint if available. Credit: jamiecollinson.com/blog/my-emacs-config/#javascript"
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name "node_modules/eslint/bin/eslint.js"
                                            root))))
        (when (and eslint (file-executable-p eslint))
          (setq-local flycheck-javascript-eslint-executable eslint))))
#+END_SRC

** Clojure (Lisp)

Can't do much without a major mode.
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode)
#+END_SRC

We definitely want CIDER, this is the bread and butter.
#+BEGIN_SRC emacs-lisp
  (use-package cider)
#+END_SRC

Company hooks to enable fuzzy completion when in minor mode cider-mode.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
#+END_SRC

** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish paredit-mode
    :hook ((clojure-mode . paredit-mode)
           (cider-mode . paredit-mode)))
#+END_SRC

** RainbowDelimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** Company
Company-mode quality of life fixes
#+BEGIN_SRC emacs-lisp
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 1)
  (setq company-selection-wrap-around t)
  (setq company-global-modes '(not org-mode))
  (global-company-mode)
#+END_SRC

** Development adjacent
*** Restclient

This is a pretty cool package that I haven't dived into enough, hoping to use is as a postman replacement.

#+BEGIN_SRC emacs-lisp
(use-package restclient)
#+END_SRC

Let's add a dash of company to that.

#+BEGIN_SRC emacs-lisp
  (use-package company-restclient
    :config (add-to-list 'company-backends 'company-restclient))
#+END_SRC


*** Fish Shell
#+BEGIN_SRC emacs-lisp
(use-package fish-mode)
#+END_SRC
*** Yaml Mode
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC
*** JSON Mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode)
#+END_SRC
*** Dockerfile Mode
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode)
#+END_SRC

* Snippets

Using [[https://github.com/AndreaCrotti/yasnippet-snippets][this community library]], which are saved in =~/.emacs.d/yasnippet-snippets=. My snippets are in =~/.emacs.d/snippets=.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/yasnippet-snippets")
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode)
    (global-set-key (kbd "M-/") 'company-yasnippet))
#+END_SRC

* Elfeed
RSS feeds - should move the feed definitions to another file.
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :bind ("C-x w" . elfeed)
  :config
  (setq elfeed-feeds
      '(("http://xkcd.com/rss.xml" comic)
	("https://www.smbc-comics.com/rss.php" comic)
	("http://reddit.com/r/emacs/.rss" emacs)
	("http://planet.emacsen.org/atom.xml" emacs)
	("http://pragmaticemacs.com/feed/" emacs)
        ("https://blog.jessfraz.com/index.xml" tech)))
  (setq-default elfeed-search-filter "@1-week-ago +unread"))
#+END_SRC
* Misc Configuration
** exec-path-from-shell (OSX specific)
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs
   '("PATH"))))
#+END_SRC
** Backups in one folder
Don't like to pollute the file tree with backups if I don't have to.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
* Unsorted
Empty!...for now.

